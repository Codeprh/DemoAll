

# 线程同步

1. 引出线程异步（不安全）导致的问题
2. 为何要线程同步？
3. 同步方式一：使用synchronized同步方法
4. 同步方式二：使用synchronized同步代码块
5. 同步方式三：使用volatile关键字
6. 同步方式四：使用ReentrantLock重入锁关键字
7. 同步方式五：使用ThreadLocal局部变量实现线程同步
8. 同步方式六：使用阻塞队列实现线程同步
9. 同步方式七：使用原子变量实现线程同步

## 非线程安全异步导致的问题

```java
#异步非线程安全加钱
public static void main(String[] args) throws InterruptedException {
        Bank bank = new Bank();
        Integer num = 10;
        Integer result = 0;
        CountDownLatch countDownLatch = new CountDownLatch(num);
        for (int i = 0; i < num; i++) {
            //异步线程
            result += num;

            Thread thread = new Thread(() -> {
                try {
                    Thread.sleep(3000);
                    Integer account = bank.addAccount(10);
                    System.out.println("线程名=" + Thread.currentThread().getName() + ",当前用户余额=" + account);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    countDownLatch.countDown();
                }
            });
            thread.start();

        }
        countDownLatch.await();
        System.out.println("用户最终余额=" + bank.getAccount());
        System.out.println("正确用户余额=" + result);
    }
```

### 线程异步导致结果

![image-20181218164622078](https://ws2.sinaimg.cn/large/006tNbRwgy1fyazt0pbxhj30yr085aby.jpg)

程序未能按照我们的预期跑起来。

## 为何要线程同步？

java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 从而保证了该变量的唯一性和准确性。

## 同步方式一：使用synchronized同步方法

```java
/**
 * 描述:
 * 线程同步1：synchronized同步方法，
 *
 * @author codingprh
 * @create 2018-12-18 5:08 PM
 */
public class SynchronizedMethodBank extends Bank {

    @Override
    public synchronized Integer addAccount(Integer money) {
        System.out.println("调用synchronized同步方法");
        return this.account += money;

    }
}
```

 注：

- synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类

![image-20181218173124647](https://ws2.sinaimg.cn/large/006tNbRwgy1fyb13tvi0ij30z709w0v1.jpg)

## 同步方式二：使用synchronized同步代码块

```java
public static void main(String[] args) throws InterruptedException {
        Bank bank = new Bank();
        Integer num = 10;
        Integer result = 0;
        CountDownLatch countDownLatch = new CountDownLatch(num);
        for (int i = 0; i < num; i++) {
            //异步线程
            result += num;

            Thread thread = new Thread(() -> {
                //synchronized (bank) {
                try {
                    Thread.sleep(3000);
                    synchronized (bank) {
                        Integer account = bank.addAccount(10);
                        System.out.println("线程名=" + Thread.currentThread().getName() + ",当前用户余额=" + account);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    countDownLatch.countDown();
                }

            });
            thread.start();

        }
        countDownLatch.await();
        System.out.println("用户最终余额=" + bank.getAccount());
        System.out.println("正确用户余额=" + result);
    }
```

 注：

- 同步是一种高开销的操作，因此应该尽量减少同步的内容。 
- 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

## 同步方式三：使用volatile关键字

```java
private volatile Integer account = 0;
```

注：**但是不推荐使用**

1. 因为volatile不能保证原子操作导致的，因此volatile不能代替synchronized
2. 此外volatile会组织编译器对代码优化，因此能不使用它就不使用它吧
3. 原理：它的原理是每次要线程要访问volatile修饰的变量时都是从内存中读取，而不是存缓存当中读取，因此每个线程访问到的变量值都是一样的。这样就保证了同步
4. 建议：volatile+fianl搭配使用：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。 

## 同步方式四：使用ReentrantLock重入锁关键字

```java
/**
 * 描述:
 * 重入锁bank
 *
 * @author codingprh
 * @create 2018-12-18 6:03 PM
 */
public class ReentrantLockBank extends Bank {

    private Lock lock = new ReentrantLock();

    @Override
    public Integer addAccount(Integer money) {
        lock.lock();
        try {
            return this.account += money;
        } finally {
            lock.unlock();
        }
    }
}
```

注：关于Lock对象和synchronized关键字的选择： 

- 最好两个都不用，使用一种java.util.concurrent包提供的机制， 能够帮助用户处理所有与锁相关的代码。 
- 如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 
- 如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 



## 同步方式五：使用ThreadLocal局部变量实现线程同步

```java
package threadSynchronization.synchronous;

/**
 * 描述:
 * ThreadLocal局部变量实现线程同步
 *
 * @author codingprh
 * @create 2018-12-19 10:30 AM
 */
public class ThreadLocalBank {
    private ThreadLocal<Integer> account = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            return 0;
        }
    };

    public Integer addAccount(Integer money) {

        account.set(account.get() + money);
        return account.get();

    }

    public Integer getAccount() {
        return account.get();
    }

}
```

注：

- 原理：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
- ThreadLocal与同步机制 
  1.  a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。
  2.  b.前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式

运行结果：

![image-20181219105522977](https://ws3.sinaimg.cn/large/006tNbRwgy1fybva2lpusj310608amz0.jpg)

正是因为每个线程都复制了一份，因此每个线程的值都等于10，但是主线程的account值没有改变。提现了采用空间换时间。

## 同步方式六：使用阻塞队列实现线程同步

**推荐使用阻塞队列实现线程同步**，前面的五种实现都是基于底层框架实现的。我们可以直接使用java.util.concurrent包下面各种同步工具类、集合等来简化我们开发。

```java
package threadSynchronization.synchronous.queuePackage;

import threadSynchronization.Bank;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * 描述:
 * 采用阻塞队列实现同步
 *
 * @author codingprh
 * @create 2018-12-19 11:16 AM
 */
public class LinkedBlockingQueueThreadMain {


    public static void main(String[] args) throws InterruptedException {
        LinkedBlockingQueue<Integer> queue1 = new LinkedBlockingQueue<>();
        Bank bank = new Bank();
        Integer num = 10;
        Integer result = 0;
        //消费线程
        new Thread(() -> {
            //消费线程
            try {
                Integer money = 0;
                while ((money = queue1.take()) >= 0) {
                    Integer account = bank.addAccount(money);
                    System.out.println(Thread.currentThread().getName() + ",用户余额=" + account + ",queue长度=" + queue1.size());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


        //生成线程
        CountDownLatch countDownLatch = new CountDownLatch(num);
        for (int i = 0; i < num; i++) {
            //异步线程
            result += num;

            Thread thread = new Thread(() -> {
                try {
                    Thread.sleep(3000);
                    queue1.put(10);
                    System.out.println(Thread.currentThread().getName() + ",队列长度=" + queue1.size());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    countDownLatch.countDown();
                }
            });
            thread.start();
        }
        countDownLatch.await();
        queue1.put(-1);
        Thread.sleep(5000);

        System.out.println("用户最终余额=" + bank.getAccount());
        System.out.println("正确用户余额=" + result);
    }

}
```

注：**推荐使用阻塞队列实现线程同步**

运行结果：

![image-20181220074431063](https://ws4.sinaimg.cn/large/006tNbRwgy1fycvdsp4rqj30yr0bytax.jpg)

## 同步方式七：使用原子变量实现线程同步

原子变量有什么优势？

使用线程同步的根本原因在于对普通变量的操作不是原子的，而原子变量是原子操作。

原子操作是什么？
原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。

在java.utils.concurrent.atomic包提供了那些原子变量？

![image-20181220075318454](https://ws4.sinaimg.cn/large/006tNbRwgy1fycvmxndi7j30aw0aidgf.jpg)

