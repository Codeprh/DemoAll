---
layout:     post
title:      大型分布式网站架构设计与实践
subtitle:   阅读：《大型分布式网站架构设计与实践》
date:       2018-11-07
author:     codingprh
header-img: img/post-bg-alibaba.jpg
catalog: true
tags:
    - 书籍
    - 分布式
---

## 面向服务的体系架构（SOA）

### 基于TCP和HTTP的RPC

#### RPC名词解析：

RPC的全程是Remote Process Call，即远程过程调用。

#### 对象的序列化：

- 对象的序列化：讲对象转换为二进制流的过程称为对象的序列化。
- 对象的反序列化：将二进制流恢复为对象的过程称为对象的反序列化。

##### 对象序列化框架性能比较：

![image-20181106141417110](https://ws3.sinaimg.cn/large/006tNbRwgy1fwybdxce6zj30la0eiwhb.jpg)

##### 对象序列化：

```java
ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        ObjectOutputStream objectOut = new ObjectOutputStream(byteOut);
        objectOut.writeObject(person);
        byte[] personByte = byteOut.toByteArray();
        return personByte;
```

##### 对象的反序列化：

```java
ByteArrayInputStream byteIn = new ByteArrayInputStream(personByte);
        ObjectInputStream objectIn = new ObjectInputStream(byteIn);
        Person person = (Person) objectIn.readObject();

        return person;
```

#### HTTP网络协议栈

![image-20181106141855630](https://ws1.sinaimg.cn/large/006tNbRwgy1fwybinmyjjj309h070wfb.jpg)

#### 基于HTTP的RPC和基于TCP的PRC比较

基于TCP的协议实现的RPC，由于处于传输层，能够更加灵活地对协议字段进行定制，减少网络传输字节数，降低网络开销，提高性能，实现更大的吞吐量和并发数。但是关注更多的底层复杂的细节，实现的代价更高，很难实现跨平台的调用。

基于HTTP的RPC使用JSON或者XML来实现数据的传输，我们不需要关注底层的细节。但是我们在网络传输的过程中占用更多的字节数，但是通过gzip的数据压缩，能够缩小这一差距。因此基于HTTP协议的RPC还是有很大优势的。

### 服务的路由和负载均衡

#### SOA解析：

SOA：公共的业务被拆分出来，形成可公用的服务，最大程度地保障了代码和逻辑的服用，避免重复建设。这种设计被称为SOA(Service-Oriented Architecture).

#### 负载均衡：

![image-20181106143516713](https://ws2.sinaimg.cn/large/006tNbRwgy1fwybznsek4j30l907hmz8.jpg)

##### 规模小的负载：

![image-20181106143948854](https://ws1.sinaimg.cn/large/006tNbRwgy1fwyc4d4u8lj30in0c6gn1.jpg)

- 通过硬编码的方式将服务地址和配置写在代码中。解决了服务的路由和负载均衡问题
- 传统的硬件负载均衡设备入F5来解决。
- 采用软件LVS或Nginx来解决。
- 采用上面的方案实现：有单点故障问题。可以通过搭建高可用的环境来解决。

##### 基于ZooKeeper的路由和负载均衡架构

![image-20181106144242070](https://ws1.sinaimg.cn/large/006tNbRwgy1fwyc7euzwfj30hk0e0q5y.jpg)

服务配置中心：能够一个动态注册和获取服务信息的地方，来统一管理服务名称和其对应的服务器列表信息。

ZooKeeper采用这种无中心化的结构解决了之前负载均衡设备所带来的单点问题，并且大大减轻了服务配置中心的压力。

工作流程：服务提供者在启动时，将其提供的服务名称、服务器地址注册到服务配置中，服务的消费者通过配置中心来获取到调用服务的机器列表，通过相应的负载均衡算法，选择其中一台服务器进行调用。在这个过程中，服务消费者只有第一次调用服务时，需要查询服务配置中心，然后将查询到的信息缓存到本地。直到服务的地址列表有变更的时候，才需要向重新向服务配置中心去获取服务的地址列表。

##### zookeeper的特性

![image-20181106145859759](https://ws1.sinaimg.cn/large/006tNbRwgy1fwycodhibtj30np05tgoz.jpg)

#### 负载均衡算法

常见的负载均衡算法有：轮训法、随机法、源地址哈希法、加权轮训法、加权随机法、最小连接法。根据具体的使用场景选取对应的算法。

##### 轮训法

```java

 /**
 * 描述:
 * 轮训算法
 *
 * @author codingprh
 * @create 2018-11-06 3:18 PM
 */
public class WheelTrainingAlgorithm {

    private Map<String, Integer> serverWeightMap = new HashMap<>();

    private static Integer pos = 0;

    public String getServer() {

        serverWeightMap.putAll(ServerWeightMapTables.getServerWeightMap());
        Set<String> keysSet = serverWeightMap.keySet();

        List<String> keysList = new ArrayList<>();
        keysList.addAll(keysSet);

        String server = null;

        synchronized (pos) {
            if (pos >= keysList.size()) {
                pos = 0;
            }
            server = keysList.get(pos);
            pos++;
        }
        return server;
    }


}
```

- 由于serverWeightMap中的地址列表是动态的，随时可能又机器上线、下线和避免可能出现并发问题，如数组越界。通过新建方法内的局部变量serverMap，先将域变量赋值到线程本地，以避免被多个线程修改。但是这样也引入了一个新问题，serverWeightMap的修改无法及时反应给serverMap，也就是服务器下线或者宕机。因此，我们在服务消费者的实现端需要进行相应的容错处理。
- ![image-20181107090945843](https://ws1.sinaimg.cn/large/006tNbRwgy1fwz87bb9uoj30og05zq5o.jpg)

##### 随机法

```java
/**
 * 描述:
 * 随机算法
 *
 * @author codingprh
 * @create 2018-11-07 9:15 AM
 */
public class RandomAlgorithm {
    private Map<String, Integer> serverMap = new HashMap<>();
    private Integer pos = 0;

    public String getServer() {

        serverMap.putAll(ServerWeightMapTables.getServerWeightMap());

        List<String> ipList = new ArrayList<>();
        ipList.addAll(serverMap.keySet());

        String server = null;
        Random random = new Random();
        pos = random.nextInt(ipList.size());

        server = ipList.get(pos);
        return server;

    }
}
```

- ![image-20181107092444949](https://ws1.sinaimg.cn/large/006tNbRwgy1fwz8mv9lz9j30p205976j.jpg)

##### 源地址哈希法

```java
/**
 * 描述:
 * 源地址哈希算法
 *
 * @author codingprh
 * @create 2018-11-07 10:11 AM
 */
public class SourceAddressHashAlgorithm {
    private Map<String, Integer> serverMap = new HashMap<>();
    private Integer pos = 0;

    public String getServer(String ipAddress) {

        serverMap.putAll(ServerWeightMapTables.getServerWeightMap());
        List<String> ipList = new ArrayList<>();
        ipList.addAll(serverMap.keySet());

        String server = null;

        Integer ipVal = ipAddress.hashCode();
        Integer pos = Math.abs(ipVal % ipList.size());
        return ipList.get(pos);
    }
}
```

- ![image-20181107102918493](https://ws3.sinaimg.cn/large/006tNbRwgy1fwzai1ck18j30o2044gnh.jpg)


##### 加权轮训法：

```java
/**
 * 描述:
 * 加权轮训算法
 *
 * @author codingprh
 * @create 2018-11-07 2:25 PM
 */
public class WeightedRotationAlgorithm {
    private Map<String, Integer> serverMap = new HashMap<>();
    private Integer pos = 0;

    public String getServer() {

        serverMap.putAll(ServerWeightMapTables.getServerWeightMap());

        Set<String> keySets = serverMap.keySet();
        Iterator<String> iterable = keySets.iterator();

        List<String> keyList = new ArrayList<>();

        while (iterable.hasNext()) {
            String server = iterable.next();

            Integer weight = serverMap.get(server);
            for (int i = 0; i < weight; i++) {
                keyList.add(server);
            }
        }

        String resultServer = null;
        synchronized (pos) {
            if (pos >= keyList.size()) {
                pos = 0;
            }
            resultServer = keyList.get(pos);
            pos++;
        }
        return resultServer;

    }

}
```

- 因为不同服务器的抗压的能力不同，给予权重配置。其他部分和轮训算法类型。

##### 加权随机算法：

```java
/**
 * 描述:
 * 加权随机算法
 *
 * @author codingprh
 * @create 2018-11-07 2:48 PM
 */
public class WeightedRandomAlgorithm {
    private Map<String, Integer> serverMap = new HashMap<>();
    private Integer pos = 0;

    public String getServer() {

        serverMap.putAll(ServerWeightMapTables.getServerWeightMap());

        Set<String> keySets = serverMap.keySet();
        List<String> ipList = new ArrayList<>();
        Iterator<String> iterator = keySets.iterator();
        while (iterator.hasNext()) {

            String server = iterator.next();
            Integer weight = serverMap.get(server);

            for (int i = 0; i < weight; i++) {
                ipList.add(server);
            }
        }
        String server = null;
        Random random = new Random();
        pos = random.nextInt(ipList.size());

        server = ipList.get(pos);
        return server;

    }

}
```



##### 最小连接数：

![image-20181107144651677](https://ws3.sinaimg.cn/large/006tNbRwgy1fwzhxzxqpyj30og04twgp.jpg)

#### 动态配置规则：

![image-20181107145449002](https://ws4.sinaimg.cn/large/006tNbRwgy1fwzi6bwla9j30og0h7wmn.jpg)

#### 路由和负载均衡的实现

##### 常规Nginx负载均衡

![image-20181107151230254](https://ws2.sinaimg.cn/large/006tNbRwgy1fwziy141acj30nd0bfq5n.jpg)

##### 基于服务配置中心：

![image-20181107151403927](https://ws3.sinaimg.cn/large/006tNbRwgy1fwziqbskuvj30io093myy.jpg)

![image-20181107151638941](https://ws3.sinaimg.cn/large/006tNbRwgy1fwzit28bz8j30oq09w7a9.jpg)

##### 配置中心的高级负载均衡：

![image-20181107151759854](https://ws4.sinaimg.cn/large/006tNbRwgy1fwziufsomkj30jo0bd41e.jpg)

#### HTTP服务网管：

![image-20181107152001586](https://ws3.sinaimg.cn/large/006tNbRwgy1fwziwi3rm5j30o30drq6y.jpg)

单节点的网关压力很大，我们可以通过搭建网关集群来解决单点问题。

![image-20181107152143675](https://ws3.sinaimg.cn/large/006tNbRwgy1fwziy9rclyj30f90een01.jpg)

## 分布式系统基础设施

### 分布式缓存

分布式缓存介绍：

![image-20181108111854686](https://ws3.sinaimg.cn/large/006tNbRwgy1fx0hjxzn4wj30lg05vdi9.jpg)

分布式缓存hash(key)%N的问题：

![image-20181108112252032](https://ws2.sinaimg.cn/large/006tNbRwgy1fx0ho1nkmqj30fd0fqdif.jpg)

![image-20181108112537457](https://ws3.sinaimg.cn/large/006tNbRwgy1fx0hqww7euj30lb05ngoi.jpg)

解决方案：采用consistent Hash方案解决：

![image-20181108112606952](https://ws3.sinaimg.cn/large/006tNbRwgy1fx0hrja4vcj30gy0b876g.jpg)

